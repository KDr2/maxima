load("load-dlsode.lisp");

/*
 * Simple interface to ODEPACK dlsode
 *
 * f       - list of the derivatives
 * yvars   - list of the dependent variables (symbols)
 * trange  - list of the form [tvar, start, stop, step]
 *           where tvar is the independent variable and
 *           start, stop, step means the solutions are determined
 *           for tvar = start + k*step while tvar < stop.
 * rtol    - desired relative error in the solution
 * atol    - desired absolute error in the solution.  If atol is a scalar
 *           this is error for all dependent variables.  If a list, its
 *           length should be the same as the number of dependent variables
 *           and is the desired local absolute error of the solution for the 
 *           dependent variable
 * mf      - method flag, only 22 has been tested
 *             10 - Nonstiff (Adams) method, no Jacobian used.
 *             21 - Stiff (BDF) method, user-supplied full Jacobian.
 *             22 - Stiff method, internally generated full Jacobian.
 *             24 - Stiff method, user-supplied banded Jacobian.
 *             25 - Stiff method, internally generated banded Jacobian.
 *
 * The output is a list of values of the form [t, y1, y2, y3, ...] which is 
 * the solution of the system at time t with the values y1, y2, y3, ....
 *
 * Here is one example give in documentation for rk:
 *
 *   dx/dt = 4-x^2-4*y^2     dy/dt = y^2-x^2+1
 *
 * for t between 0 and 4, and with values of -1.25 and 0.75 for x and
 * y at t=0:
 *
 * sol: rk([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02])$
 * plot2d ([discrete,makelist([p[1],p[3]],p,sol)], [xlabel,"t"],[ylabel,"y"])$
 *
 * To do the same with dlsode:
 *
 * sol2:dlsode([4-x^2-4*y^2,y^2-x^2+1],[x,y],[-1.25,0.75],[t,0,4,0.02], 1e-5, 1e-5, 10)$
 * plot2d ([discrete,makelist([p[1],p[3]],p,sol2)], [xlabel,"t"],[ylabel,"y"])$
 *
 */
dlsode(f, yvars, inity, trange, rtol, atol, mf) :=
  block([tvar: trange[1],
         tstart: float(trange[2]),
         tend: float(trange[3]),
         tstep: float(trange[4]),
         result: [],
         istate: 1,
         vars: cons(trange[1], yvars),
	 state],
    state: dlsode_init(f, vars, mf),
    for tout: tstart step tstep thru tend do
      block([r : dlsode_step(inity, tstart, tout, rtol, atol, istate, state)],
 	istate: r[3],
        /* Check returned istate and signal error if necessary */
        if is(istate < 0) then error('istate = r[3]),
        result: cons(cons(r[1], r[2]), result)
        ),
    return(reverse(result))
  );
